<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-595YEBLV7C"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-595YEBLV7C",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:url" content="https://whiley.org/2010/07/10/whiley-v0.2.8-released/"><title>Whiley
(Whiley v0.2.8 Released!)</title><script type=text/javascript src=js/ace.js></script>
<script type=text/javascript src=js/mode-whiley.js></script>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whiley.org/css/page.css><link rel=stylesheet href=https://whiley.org/css/menu.css><link rel=stylesheet href=https://whiley.org/css/style.css><link rel=stylesheet href=https://whiley.org/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><div class=page><header class=topbar><div class=topbar-title><a href=https://whiley.org/><div class=logo>Wy</div></a></div><div class=topbar-sep></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whiley.org/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whiley.org/news/>News</a>
<a href=https://whiley.org/install/>Install</a>
<a href=https://whiley.org/learn/>Learn</a>
<a href=http://whileylabs.com>Playground</a></div></div></div></header><div class=container><div class=content><div class=section><div class=column><h1>Whiley v0.2.8 Released!</h1><div class=post-date>Saturday, July
10th,
2010</div><hr><p>Here is the latest update for the Whiley-to-Java Compiler.  It now weighs in at around 47KLOC, spread over 272 classes.  There are 379+ distinct test inputs, which give rise to around 615 actual JUnit tests.  Anyway, the list of improvements includes:</p><ul><li><p>Fixed numerous outstanding bugs</p></li><li><p>Improved reporting of syntax errors</p></li><li><p>Added list append</p></li><li><p>Added support for recursive types</p></li><li><p>Added the type matching operator ~=</p></li><li><p>Modified syntax of define.  Instead of &ldquo;define type where cond as name&rdquo;, it&rsquo;s now &ldquo;define name as type where cond&rdquo;</p></li><li><p>Small updates to standard library</p></li><li><p>Redesigned the way Wyone handles types to enable better translation of Whiley&rsquo;s union types</p></li></ul><p>Overall, it&rsquo;s looking a lot better.  However, it still won&rsquo;t compile anything that&rsquo;s really non-trivial and there are several outstanding design flaws that need to be figured out.  These include:</p><ul><li><p>The way constrained recursive types are handled is insufficient.  The problem is that recursive types are handled using a recursive type constructor (e.g. X[int | (X left, X right)]) , but there is no equivalent for the constraints.  One possible solution here is a closer coupling between the type itself and the constraints imposed upon it.</p></li><li><p>The way type tests are implemented does not work well with type inference.  Type inference is used to prevent the need for a cast operator in Whiley.  The problem is when you perform a type test on something which is not a variable, then we cannot update the environment to reflect this.  One possible solution here is to introduce a simplified intermediate representation which uses a 3 address code.  This would then mean complex expressions where broken down into simpler ones which were connected via conditional branching.</p></li><li><p>The way boolean values are represented in the automated theorem prover, wyone, does not work well.  Wyone currently follows a classical approach where we things which return boolean values have a special status.  For example, a predicate is a special kind of function which returns a boolean.  The disadvantage of this is that it makes things rather unsymetric, and is responsible for a number of outstanding bugs.  A more unified, albeit less classical, approach would considerably simplify things.</p></li></ul><p>Right, that&rsquo;s all fow now &mdash; enjoy!</p><hr></div></div></div></body></html>