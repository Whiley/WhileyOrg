<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-595YEBLV7C"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-595YEBLV7C",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:url" content="https://whiley.org/2013/12/19/proposed-syntax-changes-for-whiley/"><title>Whiley
(Proposed Syntax Changes for Whiley)</title><script type=text/javascript src=js/ace.js></script>
<script type=text/javascript src=js/mode-whiley.js></script>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whiley.org/css/page.css><link rel=stylesheet href=https://whiley.org/css/menu.css><link rel=stylesheet href=https://whiley.org/css/style.css><link rel=stylesheet href=https://whiley.org/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><div class=page><header class=topbar><div class=topbar-title><a href=https://whiley.org/><div class=logo>Wy</div></a></div><div class=topbar-sep></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whiley.org/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whiley.org/news/>News</a>
<a href=https://whiley.org/install/>Install</a>
<a href=https://whiley.org/learn/>Learn</a>
<a href=http://whileylabs.com>Playground</a></div></div></div></header><div class=container><div class=content><div class=section><div class=column><h1>Proposed Syntax Changes for Whiley</h1><div class=post-date>Thursday, December
19th,
2013</div><hr><p>Now that I&rsquo;ve had the chance to write <a href=https://github.com/Whiley/WyBench/>a reasonable amount of code in Whiley</a>, it is time to reflect on some things I don&rsquo;t like.Â  In particular, there are a number of issues with the syntax which I&rsquo;d like to improve which I&rsquo;ll document here.</p><h2 id=function--method-declarations>Function & Method Declarations</h2><p>Currently, the syntax for a function or method in Whiley looks something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>abs</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=c1>// Return value cannot be negative
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=err>$</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=o>-</span><span class=n>x</span>
</span></span></code></pre></div><p>Although I quite like this syntax, I very much dislike the use of <code>$</code> for indicating the return value in a post-condition (i.e. <code>ensures</code> clause). It occurred to me that explicit naming of the return value would be better (in fact, <a href=https://dafny.org>Dafny</a> does this already). So, my proposed new syntax for function declarations is thus:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>function</span> <span class=n>abs</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>(</span><span class=kt>int</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// Return value cannot be negative
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=n>y</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=o>-</span><span class=n>x</span>
</span></span></code></pre></div><p>Strictly speaking, the <code>function</code> keyword is not necessary, however I think it adds some clarity. In particular, <em>functions</em> (which are <a href=https://en.wikipedia.org/wiki/Pure_function>pure</a>) now contrast explicitly with <em>methods</em> (which may have side-effects):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>method</span> <span class=n>read</span><span class=p>(</span><span class=n>String</span> <span class=n>filename</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>([</span><span class=kt>byte</span><span class=p>]</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>f</span> <span class=o>=</span> <span class=n>File</span><span class=p>.</span><span class=n>Reader</span><span class=p>(</span><span class=n>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span></code></pre></div><p>Note, the syntax for <code>method</code> declarations is still not finalised, and I&rsquo;ve been discussing it at length over in the issue tracker (see <a href=https://github.com/Whiley/WhileyCompiler/issues/204>#204</a>, <a href=https://github.com/Whiley/WhileyCompiler/issues/309>#309</a> and <a href=https://github.com/Whiley/WhileyCompiler/issues/310>#310</a>).</p><p>The final aspect of the proposed syntax change is that <em>you can omit the return value when it&rsquo;s <code>void</code></em>. For example, this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>void</span> <span class=o>::</span><span class=n>f</span><span class=p>(</span><span class=n>Reader</span> <span class=n>r</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span></code></pre></div><p>becomes this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>method</span> <span class=n>f</span><span class=p>(</span><span class=n>Reader</span> <span class=n>r</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span></code></pre></div><p>Although this is hardly a significant issue, is still a nice abbreviation.</p><h2 id=type-and-constant-declarations>Type and Constant Declarations</h2><p>One of things I really like about the current syntax for Whiley is the use of the <code>define</code> statement, which is simple and clean. However, it turns out there were some issues I hadn&rsquo;t considered. The issue revolves around the fact that the <code>define</code> keyword is overloaded. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>PI</span> <span class=n>as</span> <span class=mi>3</span><span class=p>.</span><span class=mi>1415926536</span>      <span class=c1>// defines a constant
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>define</span> <span class=n>nat</span> <span class=n>as</span> <span class=kt>int</span> <span class=k>where</span> <span class=err>$</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=c1>// defines a type!
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>nat</span> <span class=n>f</span><span class=p>()</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Math</span><span class=p>.</span><span class=n>round</span><span class=p>(</span><span class=n>PI</span><span class=p>)</span>
</span></span></code></pre></div><p>Here, we see <code>define</code> being used for defining a new constant, as well as a new type. This is problematic, since the compiler must figure out which it is. Of course, it can do that but, unfortunately, this leads to difficult to understand error messages. The compiler initially assumes a <code>define</code> statement defines a type and, if this fails, backtracks and assumes it defines a constant. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>Point</span> <span class=n>as</span> <span class=p>{</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,}</span>
</span></span></code></pre></div><p>This produces the following cryptic error message:</p><pre tabindex=0><code>./test.whiley:1: unrecognised term (int)
define Point as {int x, int y,}
                 ^^^
</code></pre><p>The programmer was trying to define a new <code>Point</code> type, but accidentally left a comma at the end. The error message is confusing, because it appears to say the <code>int</code> type doesn&rsquo;t exist! Ultimately, the problem is that the compiler initially tried to parse it as a type, but failed. So, it backtracked and tried for a constant which also failed, this time leaving an error message about why <code>{int x, int y,}</code> is not a well-formed expression.</p><p>The proposed syntax for constants and type declarations tries to be consistent with that for functions and methods:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>constant</span> <span class=n>PI</span> <span class=k>is</span> <span class=mi>3</span><span class=p>.</span><span class=mi>1415926536</span>      <span class=c1>// defines a constant
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=n>nat</span> <span class=k>is</span> <span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=k>where</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=c1>// defines a type!
</span></span></span></code></pre></div><p>With this syntax, there is no ambiguity between what is supposed to be a constant and what is supposed to be a type. Furthermore, I&rsquo;ve removed the <code>$</code> syntax in favour of explicitly named variables.</p><h2 id=local-variable-declarations>Local Variable Declarations</h2><p>One of the unusual aspects of the current syntax is that you cannot <em>declare</em> local variables. Whilst this is nice, it does causes problems. One of these arises in verification, and wasn&rsquo;t something I initially considered. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>nat</span> <span class=n>as</span> <span class=kt>int</span> <span class=k>where</span> <span class=err>$</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>nat</span> <span class=n>sum</span><span class=p>([</span><span class=n>nat</span><span class=p>]</span> <span class=n>xs</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span> <span class=c1>// result
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=c1>// index
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>while</span> <span class=n>i</span> <span class=o>&amp;</span><span class=n>lt</span><span class=p>;</span> <span class=o>|</span><span class=n>xs</span><span class=o>|</span> <span class=k>where</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>r</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=n>r</span> <span class=o>=</span> <span class=n>r</span> <span class=o>+</span> <span class=n>xs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=n>i</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>   <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>return</span> <span class=n>r</span>
</span></span></code></pre></div><p>This is a simple example illustrating that summing over a list of natural numbers yields a natural number. The loop invariants are, alas, necessary for the verifier to accept this program. In principle, the compiler could attempt to infer these loop invariants since they are simple.</p><p>Another option (which I prefer) is to allow variable declarations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>nat</span> <span class=n>sum</span><span class=p>([</span><span class=n>nat</span><span class=p>]</span> <span class=n>xs</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=n>nat</span> <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span> <span class=c1>// result
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>nat</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=c1>// index
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>while</span> <span class=n>i</span> <span class=o>&amp;</span><span class=n>lt</span><span class=p>;</span> <span class=o>|</span><span class=n>xs</span><span class=o>|:</span>
</span></span><span class=line><span class=cl>      <span class=p>...</span>
</span></span></code></pre></div><p>Since <code>r</code> and <code>i</code> are both declared to be of type <code>nat</code>, the loop invariants are no longer required since the verifier will enforce the <code>nat</code> constraints at all program points.</p><p>There are still some unresolved questions here. Firstly, I will probably still allow variables to be declared as <code>var</code>, which means they can take any type at any point. Furthermore, flow typing will still be used to restrict the type of a variable in various ways. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>get</span><span class=p>(</span><span class=kt>int</span><span class=o>|</span><span class=kc>null</span> <span class=n>x</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>x</span> <span class=k>is</span> <span class=kt>int</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=c1>// automatically retyped
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span></code></pre></div><p>And, similarly:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>f</span><span class=p>()</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>|</span><span class=kc>null</span> <span class=n>x</span> <span class=o>=</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=c1>// here, x has type null
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=c1>// now, x has type int
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>x</span>
</span></span></code></pre></div><p>Finally, an interesting question is whether or not there is any difference between the declaration <code>any x</code> and <code>var x</code>. I&rsquo;ll have to think about this!</p><h2 id=references>References</h2><p>Currently, reference types are denoted with the <code>ref</code>, like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>Point</span> <span class=n>as</span> <span class=p>{</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>::</span><span class=n>shift</span><span class=p>(</span><span class=n>ref</span> <span class=n>Point</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>amount</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>+</span> <span class=n>amount</span>
</span></span></code></pre></div><p>Here, method <code>m</code> accepts a <em>reference</em> to a <code>Point</code> object. Therefore, by assigning through it, we can produce a side-effect. My proposed syntax change is <a href=http://static.rust-lang.org/doc/0.4/rust.html#type-system>inspired by the syntax for borrowed pointers in Rust</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>type</span> <span class=n>Point</span> <span class=k>is</span> <span class=p>{</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>method</span> <span class=n>shift</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Point</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>amount</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>+</span> <span class=n>amount</span>
</span></span></code></pre></div><p>For some reason, I prefer <code>&</code> over e.g. <code>*</code> (as in C). Also, it remains an open question as to whether or not to stick with the C-like notation of <code>-></code> for dereferencing fields and, likewise, <code>*</code> for general dereferencing.</p><p>Thoughts and comments welcome!!</p><hr></div></div></div></body></html>